#ifndef CHAOS_QBL
#define CHAOS_QBL
@include "QB/points.qbl"
@include "QB/colors.qbl"

// Original: https://www.pcg-random.org/download.html#minimal-c-implementation
// *Really* minimal PCG32 code / (c) 2014 M.E. O'Neill / pcg-random.org
// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)

typedef struct{
    unsigned long state;
    unsigned long multiplier;
    unsigned long increment;
} quibble_pcg_state;

unsigned int pcg32(quibble_pcg_state *qstate){
    unsigned long oldstate = qstate->state;

    // Advance internal state
    qstate->state = oldstate * 6364136223846793005ULL + (qstate->increment|1);

    // Calculate output function (XSH RR), uses old state for max ILP
    unsigned int xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;
    unsigned int rot = oldstate >> 59u;
    return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));
}

quibble_pcg_state pcg32_init(unsigned long initstate){
    quibble_pcg_state qstate;

    qstate.multiplier = 6364136223846793005u;
    qstate.increment  = 1442695040888963407u;
    qstate.state = 0U;
    pcg32(&qstate);
    qstate.state += initstate;
    pcg32(&qstate);

    return qstate;
}

float fpcg32(quibble_pcg_state *qstate){
    return (float)(pcg32(qstate)%1000000)/1000000;
}

quibble_point_2D halfway(quibble_point_2D pt_1, quibble_point_2D pt_2){
    quibble_point_2D pt;
    pt.x = 0.5*(pt_1.x + pt_2.x);
    pt.y = 0.5*(pt_1.y + pt_2.y);
    return pt;
}

__stanza sierpinski_chaos(int num_iterations, quibble_simple_camera cam,
                          quibble_point_2D a, quibble_pcolor_rgba8888 c_a,
                          quibble_point_2D b, quibble_pcolor_rgba8888 c_b,
                          quibble_point_2D c, quibble_pcolor_rgba8888 c_c){
    quibble_pcg_state qstate = pcg32_init(qps_width*qps_height - _idx);

    float y = fpcg32(&qstate)*cam.world_size_y+cam.world_position_y;

    float x = fpcg32(&qstate)*cam.world_size_x+cam.world_position_x;

    quibble_point_2D _pt = qb_point_2D(x, y);
    quibble_pcolor_rgba8888 _clr = qb_pcolor_rgba8888(0,0,0,0,0);

    unsigned short chosen_fx;
   
    for (int _i = 0; _i < num_iterations; ++_i){
        chosen_fx = pcg32(&qstate)%3;

        switch (chosen_fx){
            case 0:
                _pt = halfway(_pt, a);
                _clr = c_a;
                break;
            case 1:
                _pt = halfway(_pt, b);
                _clr = c_b;
                break;
            case 2:
                _pt = halfway(_pt, c);
                _clr = c_c;
                break;
            default:
                break;
        }
        __split_stanza();
    }

}

__stanza rectangle_chaos(int num_iterations, quibble_simple_camera cam, 
                         quibble_pcolor_rgba8888 clr |
                         quibble_point_2D location = qb_point_2D(0,0);
                         float rotation = 0;
                         float scale_x = 1;
                         float scale_y = 1;){

    quibble_pcg_state qstate = pcg32_init(qps_width*qps_height - _idx);

    float y = fpcg32(&qstate)*cam.world_size_y+cam.world_position_y;

    float x = fpcg32(&qstate)*cam.world_size_x+cam.world_position_x;

    quibble_point_2D _pt = qb_point_2D(x, y);
    quibble_pcolor_rgba8888 _clr = qb_pcolor_rgba8888(0,0,0,0,0);

    quibble_point_2D vertex_1 =
        qb_point_2D(scale_x*cos(rotation) - scale_y*sin(rotation) + location.x,                     scale_x*sin(rotation) + scale_y*cos(rotation) + location.y);

    quibble_point_2D vertex_2 =
        qb_point_2D(scale_x*cos(rotation) + scale_y*sin(rotation) + location.x,
                    scale_x*sin(rotation) - scale_y*cos(rotation) + location.y);

    quibble_point_2D vertex_3 =
        qb_point_2D(-scale_x*cos(rotation)+scale_y*sin(rotation)+location.x,
                    -scale_x*sin(rotation)-scale_y*cos(rotation)+location.y);

    quibble_point_2D vertex_4 =
        qb_point_2D(-scale_x*cos(rotation)-scale_y*sin(rotation)+location.x,
                    -scale_x*sin(rotation)+scale_y*cos(rotation)+location.y);

    unsigned short chosen_fx;
   
    for (int _i = 0; _i < num_iterations; ++_i){
        chosen_fx = pcg32(&qstate)%4;

        switch (chosen_fx){
            case 0:
                _pt = halfway(_pt, vertex_1);
                break;
            case 1:
                _pt = halfway(_pt, vertex_2);
                break;
            case 2:
                _pt = halfway(_pt, vertex_3);
                break;
            case 3:
                _pt = halfway(_pt, vertex_4);
                break;
            default:
                break;
        }
        _clr = clr;
        __split_stanza();
    }

}

__verse constant_disk(quibble_point_2D pt |
                      float radius = 1;
                      quibble_point_2D location = qb_point_2D(0,0);
                      bool function_index = 0;){

    pt.x = (pt.x-location.x)/radius;
    pt.y = (pt.y-location.y)/radius;

    float r2 = pt.x*pt.x + pt.y*pt.y;

    float theta = M_PI;
    if (r2 > FLT_EPSILON){
        theta = atan2(pt.y,pt.x);
        if (pt.y < 0){
            theta += 2*M_PI;
        }

        float new_theta = (r2+function_index)*M_PI;

        float new_r2 = sqrt(theta/(2*M_PI));

        _pt.x = radius*new_r2*cos(new_theta)+location.x;
        _pt.y = radius*new_r2*sin(new_theta)+location.y;
    }
}

__stanza circle_chaos(int num_iterations, quibble_simple_camera cam,
                      quibble_pcolor_rgba8888 clr |
                      quibble_point_2D location = qb_point_2D(0,0);
                      float radius = 1;){

    quibble_pcg_state qstate = pcg32_init(qps_width*qps_height - _idx);

    float y = fpcg32(&qstate)*cam.world_size_y+cam.world_position_y;

    float x = fpcg32(&qstate)*cam.world_size_x+cam.world_position_x;

    quibble_point_2D _pt = qb_point_2D(x, y);
    quibble_pcolor_rgba8888 _clr = qb_pcolor_rgba8888(0,0,0,0,0);

    unsigned short chosen_fx;
   
    for (int _i = 0; _i < num_iterations; ++_i){
        chosen_fx = pcg32(&qstate)%2;

        switch (chosen_fx){
            case 0:
                @VCALL constant_disk(_pt |
                                     radius = radius;
                                     location = location;
                                     function_index = 0;);
                break;
            case 1:
                @VCALL constant_disk(_pt |
                                     radius = radius;
                                     location = location;
                                     function_index = 1;);
                break;
            default:
                break;
        }
        _clr = clr;
        __split_stanza();
    }

}


#endif
