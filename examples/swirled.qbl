@include "QB/chaos.qbl"
@include "QB/output.qbl"

__verse swirl(quibble_point_2D pt,
              quibble_pcolor_rgba8888 clr_1,
              quibble_pcolor_rgba8888 clr_2,
              quibble_pcolor_rgba8888 clr_3,
              quibble_pcolor_rgba8888 clr_4 |
              int num_ignore = 20;){

        if (pt.x > 0 && pt.y > 0){
            _clr = clr_1;
        }
        else if (pt.x > 0 && pt.y <= 0){
            _clr = clr_2;
        }
        else if (pt.x <= 0 && pt.y <= 0){
            _clr = clr_3;
        }
        else if (pt.x <= 0 && pt.y > 0){
            _clr = clr_4;
        }

        float r = sqrt(pt.y*pt.y + pt.x*pt.x);

        pt.x = _pt.x*cos(r*r) + _pt.y*sin(r*r);
        pt.y = _pt.x*sin(r*r) - _pt.y*cos(r*r);

        if (_i > num_ignore){
            histogram_output_prgba8888(pt, _clr, cam, qps);
        }
}

__poem square_shader(quibble_pixels_prgba8888 qps,
                     quibble_simple_camera qcam){

    // Drawing a black background first
    quibble_point_2D pt = qb_find_point_location(_idx, qcam);
    quibble_pcolor_rgba8888 qcolor = qb_pcolor_rgba8888(0,0,0,1,0.1);
    histogram_output_prgba8888(pt, qcolor, qcam, qps);

    // These colors have a different priority so that different threads
    // don't overlap each other at the boundaries.
    quibble_pcolor_rgba8888 v1_color = qb_pcolor_rgba8888(1,0.25,0.25,1,0.5);
    quibble_pcolor_rgba8888 v2_color = qb_pcolor_rgba8888(0.25,1,0.25,1,0.6);
    quibble_pcolor_rgba8888 v3_color = qb_pcolor_rgba8888(0.25,0.25,1,1,0.7);
    quibble_pcolor_rgba8888 v4_color = qb_pcolor_rgba8888(1,0.25,1,1,0.8);

    // Setting default color for square
    // This will be ignored because we are creating a custom verse
    qcolor = qb_pcolor_rgba8888(1,0,1,1,1);

    @SCALL rectangle_chaos(100, qcam, qcolor |
                           scale_x = 0.6; scale_y = 0.6;){
        @VCALL swirl(_pt, v1_color, v2_color, v3_color, v4_color);
    }
}

