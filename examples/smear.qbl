@include "QB/chaos.qbl"
@include "QB/output.qbl"

__verse smear(quibble_point_2D pt,
              quibble_point_2D position,
              quibble_point_2D velocity | 
              int num_ignore = 20;){

    float theta = atan(pt.y/pt.x);
    if (pt.y < 0){
        theta += 2*M_PI;
    }

    // Moving back to origin for a simpler transform
    pt.x -= position.x;
    pt.y -= position.y;

    // Scaling along x by the speed (magnitude of velocity)
    pt.x *= sqrt(pt.x*pt.x + pt.y*pt.y);

    // Rotating according to velocity direction
    pt = rotate(pt, theta);

    // Moving back to correct position
    pt.x += position.x;
    pt.y += position.y;

    if (_i > num_ignore){
        histogram_output_prgba8888(pt, _clr, cam, qps);
    }
}

__poem smear_shader(quibble_pixels_prgba8888 qps,
                    quibble_simple_camera qcam,
                    quibble_point_2D position,
                    quibble_point_2D velocity){

    // Drawing a black background first
    quibble_point_2D pt = qb_find_point_location(_idx, qcam);
    quibble_pcolor_rgba8888 qcolor = qb_pcolor_rgba8888(0,0,0,1,0.1);
    histogram_output_prgba8888(pt, qcolor, qcam, qps);

    qcolor = qb_pcolor_rgba8888(1,1,1,1,1);

    @SCALL circle_chaos(100, qcam, qcolor |
                        position = position; radius = 0.5;){
        @VCALL smear(_pt, position, velocity);
    }
}

